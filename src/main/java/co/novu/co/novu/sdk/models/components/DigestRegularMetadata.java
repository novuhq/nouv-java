/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package co.novu.co.novu.sdk.models.components;

import co.novu.co.novu.sdk.utils.Utils;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.type.TypeReference;
import java.io.InputStream;
import java.lang.Deprecated;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.Optional;

public class DigestRegularMetadata {

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("amount")
    private Optional<? extends Double> amount;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backoff")
    private Optional<? extends Boolean> backoff;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backoffAmount")
    private Optional<? extends Double> backoffAmount;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("backoffUnit")
    private Optional<? extends BackoffUnit> backoffUnit;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("digestKey")
    private Optional<? extends String> digestKey;

    @JsonProperty("type")
    private DigestRegularMetadataType type;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("unit")
    private Optional<? extends DigestRegularMetadataUnit> unit;

    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("updateMode")
    private Optional<? extends Boolean> updateMode;

    @JsonCreator
    public DigestRegularMetadata(
            @JsonProperty("amount") Optional<? extends Double> amount,
            @JsonProperty("backoff") Optional<? extends Boolean> backoff,
            @JsonProperty("backoffAmount") Optional<? extends Double> backoffAmount,
            @JsonProperty("backoffUnit") Optional<? extends BackoffUnit> backoffUnit,
            @JsonProperty("digestKey") Optional<? extends String> digestKey,
            @JsonProperty("type") DigestRegularMetadataType type,
            @JsonProperty("unit") Optional<? extends DigestRegularMetadataUnit> unit,
            @JsonProperty("updateMode") Optional<? extends Boolean> updateMode) {
        Utils.checkNotNull(amount, "amount");
        Utils.checkNotNull(backoff, "backoff");
        Utils.checkNotNull(backoffAmount, "backoffAmount");
        Utils.checkNotNull(backoffUnit, "backoffUnit");
        Utils.checkNotNull(digestKey, "digestKey");
        Utils.checkNotNull(type, "type");
        Utils.checkNotNull(unit, "unit");
        Utils.checkNotNull(updateMode, "updateMode");
        this.amount = amount;
        this.backoff = backoff;
        this.backoffAmount = backoffAmount;
        this.backoffUnit = backoffUnit;
        this.digestKey = digestKey;
        this.type = type;
        this.unit = unit;
        this.updateMode = updateMode;
    }
    
    public DigestRegularMetadata(
            DigestRegularMetadataType type) {
        this(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(), type, Optional.empty(), Optional.empty());
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> amount() {
        return (Optional<Double>) amount;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Boolean> backoff() {
        return (Optional<Boolean>) backoff;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Double> backoffAmount() {
        return (Optional<Double>) backoffAmount;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<BackoffUnit> backoffUnit() {
        return (Optional<BackoffUnit>) backoffUnit;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<String> digestKey() {
        return (Optional<String>) digestKey;
    }

    @JsonIgnore
    public DigestRegularMetadataType type() {
        return type;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<DigestRegularMetadataUnit> unit() {
        return (Optional<DigestRegularMetadataUnit>) unit;
    }

    @SuppressWarnings("unchecked")
    @JsonIgnore
    public Optional<Boolean> updateMode() {
        return (Optional<Boolean>) updateMode;
    }

    public final static Builder builder() {
        return new Builder();
    }

    public DigestRegularMetadata withAmount(double amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = Optional.ofNullable(amount);
        return this;
    }

    public DigestRegularMetadata withAmount(Optional<? extends Double> amount) {
        Utils.checkNotNull(amount, "amount");
        this.amount = amount;
        return this;
    }

    public DigestRegularMetadata withBackoff(boolean backoff) {
        Utils.checkNotNull(backoff, "backoff");
        this.backoff = Optional.ofNullable(backoff);
        return this;
    }

    public DigestRegularMetadata withBackoff(Optional<? extends Boolean> backoff) {
        Utils.checkNotNull(backoff, "backoff");
        this.backoff = backoff;
        return this;
    }

    public DigestRegularMetadata withBackoffAmount(double backoffAmount) {
        Utils.checkNotNull(backoffAmount, "backoffAmount");
        this.backoffAmount = Optional.ofNullable(backoffAmount);
        return this;
    }

    public DigestRegularMetadata withBackoffAmount(Optional<? extends Double> backoffAmount) {
        Utils.checkNotNull(backoffAmount, "backoffAmount");
        this.backoffAmount = backoffAmount;
        return this;
    }

    public DigestRegularMetadata withBackoffUnit(BackoffUnit backoffUnit) {
        Utils.checkNotNull(backoffUnit, "backoffUnit");
        this.backoffUnit = Optional.ofNullable(backoffUnit);
        return this;
    }

    public DigestRegularMetadata withBackoffUnit(Optional<? extends BackoffUnit> backoffUnit) {
        Utils.checkNotNull(backoffUnit, "backoffUnit");
        this.backoffUnit = backoffUnit;
        return this;
    }

    public DigestRegularMetadata withDigestKey(String digestKey) {
        Utils.checkNotNull(digestKey, "digestKey");
        this.digestKey = Optional.ofNullable(digestKey);
        return this;
    }

    public DigestRegularMetadata withDigestKey(Optional<? extends String> digestKey) {
        Utils.checkNotNull(digestKey, "digestKey");
        this.digestKey = digestKey;
        return this;
    }

    public DigestRegularMetadata withType(DigestRegularMetadataType type) {
        Utils.checkNotNull(type, "type");
        this.type = type;
        return this;
    }

    public DigestRegularMetadata withUnit(DigestRegularMetadataUnit unit) {
        Utils.checkNotNull(unit, "unit");
        this.unit = Optional.ofNullable(unit);
        return this;
    }

    public DigestRegularMetadata withUnit(Optional<? extends DigestRegularMetadataUnit> unit) {
        Utils.checkNotNull(unit, "unit");
        this.unit = unit;
        return this;
    }

    public DigestRegularMetadata withUpdateMode(boolean updateMode) {
        Utils.checkNotNull(updateMode, "updateMode");
        this.updateMode = Optional.ofNullable(updateMode);
        return this;
    }

    public DigestRegularMetadata withUpdateMode(Optional<? extends Boolean> updateMode) {
        Utils.checkNotNull(updateMode, "updateMode");
        this.updateMode = updateMode;
        return this;
    }
    
    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        DigestRegularMetadata other = (DigestRegularMetadata) o;
        return 
            java.util.Objects.deepEquals(this.amount, other.amount) &&
            java.util.Objects.deepEquals(this.backoff, other.backoff) &&
            java.util.Objects.deepEquals(this.backoffAmount, other.backoffAmount) &&
            java.util.Objects.deepEquals(this.backoffUnit, other.backoffUnit) &&
            java.util.Objects.deepEquals(this.digestKey, other.digestKey) &&
            java.util.Objects.deepEquals(this.type, other.type) &&
            java.util.Objects.deepEquals(this.unit, other.unit) &&
            java.util.Objects.deepEquals(this.updateMode, other.updateMode);
    }
    
    @Override
    public int hashCode() {
        return java.util.Objects.hash(
            amount,
            backoff,
            backoffAmount,
            backoffUnit,
            digestKey,
            type,
            unit,
            updateMode);
    }
    
    @Override
    public String toString() {
        return Utils.toString(DigestRegularMetadata.class,
                "amount", amount,
                "backoff", backoff,
                "backoffAmount", backoffAmount,
                "backoffUnit", backoffUnit,
                "digestKey", digestKey,
                "type", type,
                "unit", unit,
                "updateMode", updateMode);
    }
    
    public final static class Builder {
 
        private Optional<? extends Double> amount = Optional.empty();
 
        private Optional<? extends Boolean> backoff = Optional.empty();
 
        private Optional<? extends Double> backoffAmount = Optional.empty();
 
        private Optional<? extends BackoffUnit> backoffUnit = Optional.empty();
 
        private Optional<? extends String> digestKey = Optional.empty();
 
        private DigestRegularMetadataType type;
 
        private Optional<? extends DigestRegularMetadataUnit> unit = Optional.empty();
 
        private Optional<? extends Boolean> updateMode = Optional.empty();  
        
        private Builder() {
          // force use of static builder() method
        }

        public Builder amount(double amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = Optional.ofNullable(amount);
            return this;
        }

        public Builder amount(Optional<? extends Double> amount) {
            Utils.checkNotNull(amount, "amount");
            this.amount = amount;
            return this;
        }

        public Builder backoff(boolean backoff) {
            Utils.checkNotNull(backoff, "backoff");
            this.backoff = Optional.ofNullable(backoff);
            return this;
        }

        public Builder backoff(Optional<? extends Boolean> backoff) {
            Utils.checkNotNull(backoff, "backoff");
            this.backoff = backoff;
            return this;
        }

        public Builder backoffAmount(double backoffAmount) {
            Utils.checkNotNull(backoffAmount, "backoffAmount");
            this.backoffAmount = Optional.ofNullable(backoffAmount);
            return this;
        }

        public Builder backoffAmount(Optional<? extends Double> backoffAmount) {
            Utils.checkNotNull(backoffAmount, "backoffAmount");
            this.backoffAmount = backoffAmount;
            return this;
        }

        public Builder backoffUnit(BackoffUnit backoffUnit) {
            Utils.checkNotNull(backoffUnit, "backoffUnit");
            this.backoffUnit = Optional.ofNullable(backoffUnit);
            return this;
        }

        public Builder backoffUnit(Optional<? extends BackoffUnit> backoffUnit) {
            Utils.checkNotNull(backoffUnit, "backoffUnit");
            this.backoffUnit = backoffUnit;
            return this;
        }

        public Builder digestKey(String digestKey) {
            Utils.checkNotNull(digestKey, "digestKey");
            this.digestKey = Optional.ofNullable(digestKey);
            return this;
        }

        public Builder digestKey(Optional<? extends String> digestKey) {
            Utils.checkNotNull(digestKey, "digestKey");
            this.digestKey = digestKey;
            return this;
        }

        public Builder type(DigestRegularMetadataType type) {
            Utils.checkNotNull(type, "type");
            this.type = type;
            return this;
        }

        public Builder unit(DigestRegularMetadataUnit unit) {
            Utils.checkNotNull(unit, "unit");
            this.unit = Optional.ofNullable(unit);
            return this;
        }

        public Builder unit(Optional<? extends DigestRegularMetadataUnit> unit) {
            Utils.checkNotNull(unit, "unit");
            this.unit = unit;
            return this;
        }

        public Builder updateMode(boolean updateMode) {
            Utils.checkNotNull(updateMode, "updateMode");
            this.updateMode = Optional.ofNullable(updateMode);
            return this;
        }

        public Builder updateMode(Optional<? extends Boolean> updateMode) {
            Utils.checkNotNull(updateMode, "updateMode");
            this.updateMode = updateMode;
            return this;
        }
        
        public DigestRegularMetadata build() {
            return new DigestRegularMetadata(
                amount,
                backoff,
                backoffAmount,
                backoffUnit,
                digestKey,
                type,
                unit,
                updateMode);
        }
    }
}

